#!/usr/bin/env python3
# -*- coding: utf-8 -*-
__author__ = "Qingqing Cao, https://awk.ai/, Twitter@sysnlp"

import argparse
from datetime import datetime

import numpy as np

from pathlib import Path


def gen_one_energy(energy_file):
    for line in open(energy_file):
        yield line


def main(args):
    log_path = Path(args.log_dir)
    energy_log = args.energy_log
    prefix = args.prefix
    iterations = args.iterations
    start_times = [(i, log_path.joinpath(f"{prefix}{i}-start.txt")
                    .read_text().strip())
                   for i in range(1, iterations + 1)
                   if log_path.joinpath(f"{prefix}{i}-start.txt").exists()]
    end_times = [(i, log_path.joinpath(f"{prefix}{i}-end.txt")
                  .read_text().strip())
                 for i in range(1, iterations + 1)
                 if log_path.joinpath(f"{prefix}{i}-end.txt").exists()]

    energy = []
    latency = []
    # energy_list = []
    energy_gen = gen_one_energy(energy_log)
    last_line = None
    for i, ((b, start), (_, end)) in enumerate(zip(start_times, end_times)):
        power_values = []
        start_record = False
        start_time = datetime.strptime(start, '%Y-%m-%d-%H-%M-%S')
        end_time = datetime.strptime(end, '%Y-%m-%d-%H-%M-%S')
        # print(f"iter{i + 1}", start, end)
        while True:
            try:
                if last_line is not None:
                    line = last_line
                    last_line = None
                else:
                    line = next(energy_gen)
                items = line.split()
                timestamp = items[0]
                log_time = datetime.strptime(timestamp, '%Y-%m-%d-%H-%M-%S')
                power = float(items[2])
                if log_time >= start_time:
                    start_record = True
                if log_time >= end_time:
                    last_line = line
                    # print(start, end, power_values)
                    # print()
                    break
                if start_record:
                    power_values.append(power)
            except StopIteration:
                print(f"iter {start} {end}, finished reading {energy_log}")
                break
        energy.append(sum(power_values) / 3.6e6)
        latency.append(len(power_values))
        print(f'{prefix}={b}, {sum(power_values):.2f}, '
              f'{len(power_values)}, {start}, {end}')
        # energy_list.append(power_values)
    print(f"found {len(energy)} logs")
    avg = np.mean(energy)
    std = np.std(energy)
    print(f'{log_path} energy avg (kwh): {avg:.5f}')
    print(f'{log_path} energy std (kwh): {std:.5f}')
    print(f'{log_path} energy avg (J): {avg * 3.6e6:.2f}')
    print(f'{log_path} energy std (J): {std * 3.6e6:.2f}')
    print(f'{log_path} energy std (%): {std * 100 / avg:.2f}')
    latency_avg = np.mean(latency)
    latency_std = np.std(latency)
    print(f"{log_path} latency avg (s): {latency_avg:.3f}")
    print(f"{log_path} latency std (s): {latency_std:.3f}")
    print(f"{log_path} latency std (%): {latency_std * 100 / latency_avg:.2f}")
    if args.num_examples:
        per_ex_avg = avg / args.num_examples * args.batch_size
        per_ex_std = std / args.num_examples * args.batch_size
        print(f"{log_path} per batch ({args.batch_size}) energy")
        print(f"avg (J), std (J), std ratio (%)")
        print(f"{per_ex_avg * 3.6e6:.1f}, {per_ex_std * 3.6e6:.1f}, "
              f"{per_ex_std * 100 / per_ex_avg:.1f}")
        per_t_ex_avg = latency_avg / args.num_examples * args.batch_size
        per_t_ex_std = latency_std / args.num_examples * args.batch_size
        print(f"{log_path} per batch ({args.batch_size}) latency")
        print(f"avg (s), std (s), std ratio (%)")
        print(f"{per_t_ex_avg:.3f}, {per_t_ex_std:.3f}, "
              f"{per_t_ex_std * 100 / per_t_ex_avg:.1f}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("energy_log", type=str,
                        help="energy log file generated by wattsup.py")
    parser.add_argument("-d", "--log_dir", type=str,
                        help="log dir containing start and end time data")
    parser.add_argument("-p", "--prefix", type=str, default='b',
                        help="log dir prefix")
    parser.add_argument("-i", "--iterations", default=5, type=int,
                        help="number of iterations in the time data", )
    parser.add_argument("-n", "--num_examples", default=0, type=int,
                        help="number of examples to get "
                             "average energy per example ", )
    parser.add_argument("-b", "--batch_size", default=32, type=int,
                        help="batch size to run examples", )
    main(parser.parse_args())
